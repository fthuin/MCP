\subsection{Problème principal}
\subsubsection*{Spécifications}
\noindent \textbf{En-tête :} public static void switchCadran(int[] tab, int decalage)\\
\noindent \textbf{Pré :} tab est un tableau d'entiers != null\\
\indent $\dot{\wedge}$ decalage est un nombre entiers positifs\\
\textbf{Post :} tous les éléments du tableau aux positions i sont déplacés aux positions (i+decalage \% tab.length)\\
\textbf{Résultat :} - \\

\noindent \textbf{Environement: }\\
int switchDone\\
int pgcd\\

\noindent \textbf{Invariant :}

\begin{tabular}{lp{14cm}}

& $\mathrm{decalage}=\mathrm{decalage}_{0}$ \\
$\dot{\wedge}$ & $\forall i \in \mathbb{Z} \mid i < \mathrm{switchDone} $, $\forall j \in \mathbb{Z} \mid j < \frac{\mathrm{tab.length}}{\mathrm{PGCD}}$ \\
$\Rightarrow$ & les éléments aux indices $tab_{0}[(j \times decalage + i) \% tab.length]$ sont déplacés aux indices $(((j+1)\times decalage)+i) \% tab.length$ \\
\end{tabular}\\

\noindent \textbf{Condition d'arrêt: }\\
switchDone==pgcd \\

\noindent \begin{tabular}{l|l}
\textbf{Init: } & \textbf{Iter: }\\
switchDone := 0; & switchCadran2(tab, switchDone, decalage, tab.length / pgcd); \\
pgcd := pgcd(tab.length,decalage); & switchDone=switchDone+1;\\
\end{tabular}\\

\noindent \textbf{Clot: } -

\subsubsection*{\{Pre\} Init \{Inv\}}

\{decalage = $decalage_{0}$, tab = tab$_{0}$ [val$_{0}^{0}$, val$_{0}^{1}$, ... ,val$_{0}^{tab.length-1}$])\} tel que \\tab est un tableau d'entiers != null
$\dot{\wedge}$ decalage est un nombre entiers positifs\\

INIT

\{switchDone = 0, pgcd = PGCD(tab.length, decalage)\} \footnote{Par manque d'espace nous ne prouverons pas l'exactitude de la fonction PGCD mais elle peut être prouvée de la même manière que vue au cours}

On a bien qu'il n'existe aucun $i < \mathrm{switchDone}$, aucun élément n'est déplacé au sein de tab.

L'invariant est donc vérifié sur INIT.

\subsubsection*{\{Inv \&\& !H \} Iter \{Inv\}}

Nous avons que lors de l'Iter, l'environnement symbolique suivant \{decalage = $decalage_{1}$, tab = tab$_{1}$ [val$_{1}^{0}$, val$_{1}^{1}$, ... ,val$_{1}^{tab.length-1}$])\}

A chaque itération, switchCadran2 est appelé avec les arguments : tab,
switchDone (incrémenté), décalage et tab.length / PGCD.

Nous respectons bien les préconditions de switchCadran2 car:
\begin{enumerate}
 \item tab donné à switchCadran2 est le tableau non nul composé d'entiers reçu en paramètre dont les éléments ont éventuellement été deplacés
 \item switchDone est positif
 \item decalage respecte les precondition de switchCadran et est donc positif
 \item tab.length / PGCD qui est bien compris entre 0 et tab.length
\end{enumerate}


De ce fait,
selon la spécification de switchCadran2 prouvé précédemment, nous avons
que chaque élément $x \in [0\cdots
    \frac{\mathrm{tab.length}}{\mathrm{PGCD}}[$ est déplacé à la
        position $(x\times \mathrm{decal})+i \% \mathrm{tab.length}$ avec $i < \mathrm{switchDone}$

On a donc que les éléments aux indices $tab_{0}[(j \times decalage + i) \% tab.length]$ sont déplacés aux indices $(((j+1)\times decalage)+i) \% tab.length$ pour chaque $i < \mathrm{switchDone}$ et $j \leq \frac{\mathrm{tab.length}}{\mathrm{PGCD}}$ 
A chaque itération, nous avons donc que $switchDone \times \frac {\mathrm{tab.length}}{\mathrm{PGCD}}$ décalages ont été effectué
\subsubsection*{\{Inv \&\& H\} Clot \{Post\}}
Nous avons que lors de l'Iter, l'environnement symbolique suivant \{decalage = $decalage_{1}$, tab = tab$_{1}$ [val$_{1}^{0}$, val$_{1}^{1}$, ... ,val$_{1}^{tab.length-1}$])\}
 Nous avons que switchDone=PGCD ce qui implique qu'on a déplacé
$\mathrm{PGCD}\times \frac{\mathrm{tab.length}}{\mathrm{PGCD}}$ éléments et
que chacun d'entre eux est déplacé une et une seule fois (comme démontré lors de la théorie du problème). Tous les élémetnts de tab sont donc déplacés de décal positions.

\subsubsection*{Preuve de terminaison}

Variant  : $pgcd - switchDone$

INIT et INV:  $\Rightarrow 0 \leq switchDone \leq pgcd$ sachant que PGCD ne renvoie que des valeurs positives donc $pgcd - switchDone \geq 0$. Notre variant est bien positif ou nul.\\ 

Vérifions maintenant que notre variant décroit sur Iter. Prenons Inv $\&\&$ !H \\

E = $\{ switchDone = switchDone_{1}, pgcd = pgcd_{1}, tab = tab_{1}\}$\\
tq $(INV \wedge switchDone_{1} != pgcd_{1})$.\\

Une seule instruction va nous intéresse ici : \\

\begin{center}
  $switchDone++;$\\
 \end{center} 
 
Cela nous donne un nouvel environnement :\\

E' = $\{switchDone = switchDone_{1}+1, ...\}$ tq (Idem).\\

$Var(E) = pgcd - switchDone_{1}$
$Var(E') = pgcd - switchDone = pgcd - (switchDone_{1}+1)$

On a donc : $Var(E) = pgcd - switchDone_{1} > pgcd - (switchDone_1 +1) = pgcd - switchDone = Var(E')$.\\

On a donc bien un variant qui décroit sur Iter.\\

Ceci nous montre que le problème général se finira toujours. 

Nous avons donc fini la correction partielle et prouvé que cet algorithme s'arrête toujours. On peut donc en conclure que cet algorithme est correct, suivant ses spécifications. \\
